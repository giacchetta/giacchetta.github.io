---
title: "Github Actions"
description: "Deep dive into my Github Actions experience"
category: "credentials"
publishDate: 2025-08-09
updateDate: 2025-08-30
featured: true
---
## Basic
To kick things off, let's clear up some potential confusion for those who are new to this.

> GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline.
Continuous integration (CI) is a software practice that requires frequently committing code to a shared repository. Thus, you can continuously build and test the code to make sure that the commit doesn't introduce errors.
On the other hand, Continuous deployment (CD) is the practice of using automation to publish and deploy software updates to your servers.

Just a quick heads-up about GitHub Actions – this is to make sure we're all on the same page. Now, let's dive into some stuff you won't find in the official docs, which, by the way, are super detailed and can be found at [Github Actions Docs](https://docs.github.com/en/actions)

## TypeScript Actions
So, why a TypeScript Action, you ask? Well, you don't have to use one. Plenty of folks create their Actions in plain old Bash scripts. But GitHub actually lets you build your actions directly in JavaScript, which means you don't need to run an Action inside a container.

If you're looking to dive into creating your own [GitHub Action with TypeScript](https://github.com/actions/typescript-action), a super solid place to start is the official template. This template is a goldmine of good practices and, even though it might look a bit much at first glance with all its components, it's really functional. It comes packed with compilation support, tests, a validation workflow, and guidance for publishing and versioning.

This template is mostly geared towards making your Actions public, but you can totally use it for internal stuff too. Just skip the 'publishing and versioning' bits, and the rest still applies. I actually use most of my Actions internally, so we'll be focusing on that use case. Once you're comfortable and ready to make your new Action public, it's a breeze to turn on those publishing and versioning workflows.

The example in the template is pretty basic – so basic it might even feel useless. I mean, it's just an example, right? But it's a bit too short to really show you how to tackle more complex scenarios. So, we're going to build more examples, starting from simple stuff and moving up to more intricate cases where you can bring your real code into your actions and hook them up with external libraries. That's where things get really interesting and you see the true advantage over Bash scripts!

All our examples will include Jest Unit Testing, another huge plus over Bash. We can simulate (mock) all our functions, statements, and so on in our code to get awesome code coverage. Good code coverage is super important because every time we tweak something in the code, even a tiny little bit, we can be sure our Action will still run perfectly.

Alright, let's get started on our first example!
